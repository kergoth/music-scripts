#!/bin/bash

. "$(dirname "$0")/common-music.sh"
. "$(dirname "$0")/trap.sh"

case "$BASH_VERSION" in
    '')
        trap 'rm -f $cleanfiles; on_exit' EXIT
        ;;
    *)
        trap 'rm -f $cleanfiles' EXIT
        ;;
esac
audiofiles="$(mktemp -t "${0##*/}.XXXXXX")" || exit 1
cleanfiles="$audiofiles"
trap 'rm -f "$audiofiles"' INT TERM

set -e

PATH="$(cd "$(dirname "$0")" && pwd):$PATH"

investigate_threshold=1
prefix=
albumsdir=${prefix}Albums
extrasdir="${prefix}Albums With Extra Tracks"
incompletedir="${prefix}Incomplete Albums"
singlesdir=${prefix}Singles
singletracksdir="${prefix}Single Tracks"
samplersdir="${prefix}Samplers"
# Genres that get their own toplevel directories to ease navigation
# Game and Soundtrack also get flattened, as I rarely browse them by artist
hoistedgenresdir="${prefix}%s Albums"
hoisted_genres="Game|Soundtrack|Christmas|Classical"
flattened_genres="Game|Soundtrack"
flattened_dirs="$samplersdir"

# Games with data tracks and amazon albums whose videos and booklets are
# counted in the track total. This blacklist only allows one track to be
# missing at this time.
incomplete_blacklist="Descent Mac Game Soundtrack|Shadow Warrior|Fantasy General|Stargunner Original Soundtrack|King's Quest VI Heir Today, Gone Tomorrow|Command & Conquer： Red Alert： Counterstrike|Command & Conquer： Tiberian Dawn： Covert Operations|Warcraft II： Tides of Darkness|Total Annihilation|Moto Racer|Return to Zork|Quake|Hexen II|.*\\[\\+video\\]|.*\\[\\+Digital Booklet\\]"
soundtrack_blacklist="Soundtrack For The Voices In My Head.*"

usage() {
    cat >&2 <<END
${0##*/} [options] LIBRARY_DIR [LIBRARY_DIR..]

Options:
    -o DESTDIR    Link/move files to DESTDIR (default: \$PWD)
    -v    Verbose output
    -i    Link tracks individually rather than album folders
    -H    Hard link tracks rather than soft link (only useful with -i)
    -m    Move/rename instead of linking
    -d    Assume multi-disc albums are separated one disc per folder
END
    exit 2
}

destdir=.
verbose=0
individual=0
hard_link_individual=0
move=0
separated_disc_folders=0
dry_run=0
while getopts o:viHmdnh opt; do
    case "$opt" in
        o)
            destdir="$(abspath "$OPTARG")"
            ;;
        v)
            verbose=1
            ;;
        i)
            individual=1
            ;;
        H)
            hard_link_individual=1
            ;;
        m)
            move=1
            ;;
        d)
            separated_disc_folders=1
            ;;
        n)
            dry_run=1
            ;;
        \? | h)
            usage
            ;;
    esac
done
shift $((OPTIND - 1))

if [ $# -eq 0 ]; then
    set -- .
fi

linkargs=
if [ $hard_link_individual -eq 0 ]; then
    linkargs="$linkargs -sr"
elif [ $individual -eq 0 ]; then
    echo >&2 "Warning: -H has no effect without -i"
fi

if [ $move -eq 1 ]; then
    link () {
        mv "$@"
    }
else
    if which gln >/dev/null 2>&1; then
        link () {
            gln $linkargs "$@"
        }
    else
        link () {
            ln $linkargs "$@"
        }
    fi
fi


preparebar 40
totaldir=$#
for library_dir; do
    library_dir="$(abspath "$library_dir")"
    if [ "$library_dir" = "$(pwd -P)" ]; then
        # Don't recurse into ourselves
        continue
    fi
    curdir=1
    totaldir=$(for dir in "$library_dir"/*/*; do echo; done | wc -l | xargs)
    for dir in "$library_dir"/*/*/; do
        if [ $verbose -eq 0 ]; then
            clearbar
        fi
        progressbar "$curdir" "$totaldir" "${library_dir##*/}" "$curdir/$totaldir"
        curdir=$((curdir + 1))
        if [ ! -e "$dir" ]; then
            continue
        fi
        dir="${dir%/}"
        base="${dir##*/}"
        music_find "$dir" >"$audiofiles"
        count="$(wc -l <"$audiofiles" | xargs)"
        if [ $count -lt 1 ]; then
            continue
        fi
        first="$(head -n 1 "$audiofiles")"
        eval_common_metadata "$first"

        if [ $separated_disc_folders -eq 1 ]; then
            total="$(get_album_track_total_indiv_discs "$dir" || :)"
        else
            total="$(get_album_track_total "$dir" || :)"
        fi
        genre="$(get_genre "$first" "$soundtrack_blacklist")"

        if [ -z "$total" ]; then
            if [ $count -gt 1 ]; then
                d="$albumsdir"
            else
                d="$singletracksdir"
            fi
        elif [ $count -eq $total ]; then
            if echo "$releasetype" | tr '/,' '  ' | grep -qwi single \
                || [ $total -eq 1 ] || echo "$base" | grep -q Single; then
                d="$singlesdir"
            else
                d="$albumsdir"
            fi
        elif [ $count -gt $total ]; then
            # The most common case is multiple discs
            # find "$dir/" -not -name ._\* \( -iname \*.flac -o -iname \*mp3 -o -iname \*.m4a -o -iname \*.ogg \)
            d="$extrasdir"
        elif [ $total -eq 1 ]; then
            # Shouldn't be possible to get here
            echo >&2 "Error: total is 1, but count is less than 1"
            exit 1
            d="$singletracksdir"
        else
            if [ $count -gt "$investigate_threshold" ]; then
                if [ $count -eq $((total - 1)) ] && echo "$base" | grep -qEx "$incomplete_blacklist"; then
                    d="$albumsdir"
                else
                    # Possibly screwed up, or an incomplete album
                    d="$incompletedir"
                fi
            else
                d="$singletracksdir"
            fi
        fi

        rel="$(relpath "$dir" "$library_dir")"
        if [ $verbose -eq 1 ]; then
            clearbar
            echo "$rel: $count / $total -> $d"
        fi
        if [ "$d" = "$singletracksdir" ]; then
            dest="$d"
            if [ $dry_run -eq 0 ]; then
                mkdir -p "$dest"
            fi
            ext="${first##*.}"
            if [ -z "$artist" ]; then
                artist="[unknown]"
            fi
            newfirst="$(fn_sanitize "$artist - $title.$ext")"
            if [ -e "$destdir/$dest/$newfirst" ]; then
                echo >&2 "Error: $dest/$newfirst already exists, can't link from $dir"
                continue
            fi
            if [ $dry_run -eq 0 ]; then
                link "$first" "$dest/$newfirst"
            fi
        else
            dest=
            if [ -n "$hoisted_genres" ] || [ -n "$flattened_genres" ]; then
                if [ -n "$hoisted_genres" ] \
                    && echo "$genre" | grep -Eqx "$hoisted_genres"; then
                    d="$(printf "$hoistedgenresdir" "$genre")"
                fi
                if [ -n "$flattened_genres" ] \
                    && echo "$genre" | grep -Eqx "$flattened_genres"; then
                    dest="$d/$base"
                fi
            fi

            if echo "$base" | grep -qwi sampler; then
                d="$samplersdir"
            fi

            if echo "$d" | grep -Eqx "$flattened_dirs"; then
                dest="$d/$base"
            elif [ -z "$dest" ]; then
                dest="$d/$rel"
            fi
            dest="$destdir/$dest"

            if [ $individual -eq 1 ]; then
                if [ -d "$dest" ]; then
                    echo >&2 "Error: $dest already exists, can't link from $dir"
                    continue
                fi
                if [ $dry_run -eq 0 ]; then
                    mkdir -p "$dest"
                fi
                while read -r fn; do
                    if [ $dry_run -eq 0 ]; then
                        link "$fn" "$dest/"
                    fi
                done <"$audiofiles"
            else
                dest_parent="$(dirname "$dest")"
                if [ $dry_run -eq 0 ]; then
                    mkdir -p "$dest_parent"
                fi
                if [ -h "$dest" ]; then
                    if [ -d "$dest" ]; then
                        olddest="$(cd "$dest" && pwd -P)"
                    else
                        olddest="$(cd "$dest_parent" && abspath "$(readlink "$base")")"
                    fi
                    absdir="$(cd "$dir" && pwd -P)"
                    if [ "$olddest" != "$absdir" ]; then
                        echo >&2 "Error: $dest exists but points to $olddest, not $absdir"
                        continue
                    fi
                fi
                if [ $dry_run -eq 0 ]; then
                    rm -f "$dest"
                    link "$dir" "$dest"
                fi
            fi

        fi
    done
    echo
done
